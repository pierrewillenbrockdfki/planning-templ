#include "TemporalConstraintNetwork.hpp"
#include <graph_analysis/WeightedEdge.hpp>
#include <graph_analysis/algorithms/FloydWarshall.hpp>

using namespace templ::solvers::temporal::point_algebra;
using namespace graph_analysis;


namespace templ {
namespace solvers {
namespace temporal {

TemporalConstraintNetwork::TemporalConstraintNetwork()
    : mpDistanceGraph( new graph_analysis::lemon::DirectedGraph() )
{
}

TemporalConstraintNetwork::~TemporalConstraintNetwork()
{
}

void TemporalConstraintNetwork::addTimePoint(point_algebra::TimePoint::Ptr t)
{
    mpDistanceGraph->addVertex(t);
}

void TemporalConstraintNetwork::addIntervalConstraint(IntervalConstraint::Ptr i)
{
	mpDistanceGraph->addEdge(i);
}

// stp(N) is generated by upper-lower bounds of range on disjunctive intervals
void TemporalConstraintNetwork::stp()
{
	BaseGraph::Ptr graph = mpDistanceGraph->copy();
	
	TemporalConstraintNetwork tcn;
	
	double n = getEdgeNumber();
	EdgeIterator::Ptr edgeIt = graph->getEdgeIterator();
	
	IntervalConstraint::Ptr edge,prevEdge;
	double max, min;
	edgeIt->next();
	edge = boost::dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );
	while (true)
	{
		if (edgeIt->next())
		{
			IntervalConstraint::Ptr nextEdge = boost::dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );
			TimePoint::Ptr source0 = edge->getSourceVariable();
			TimePoint::Ptr source1 = nextEdge->getSourceVariable();
			TimePoint::Ptr target0 = edge->getTargetVariable();
			TimePoint::Ptr target1 = nextEdge->getTargetVariable();

			// check each two edges if they have the same source and target (compare edge and nextEdge)
			// if yes; then we must find the smallest lower bound and the biggest upper bound
			// if not; we add edge in the final graph (tcn)
			if (source0 == source1 && target0 == target1)
			{
				max = 0;
				min = std::numeric_limits<double>::infinity();
				while (source0 == source1 && target0 == target1)
				{
					if (max < edge->getUpperBound()) max = edge->getUpperBound();
					if (min > edge->getLowerBound()) min = edge->getLowerBound();
					prevEdge = edge;
					edge = nextEdge;
					if (!(edgeIt->next())) 
					{
						break;
					}
					
					nextEdge = boost::dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );
					source0 = edge->getSourceVariable();
					source1 = nextEdge->getSourceVariable();
					target0 = edge->getTargetVariable();
					target1 = nextEdge->getTargetVariable();
					
				}
				if (max < edge->getUpperBound()) max = edge->getUpperBound();
				if (min > edge->getLowerBound()) min = edge->getLowerBound();
				
				IntervalConstraint::Ptr i(new IntervalConstraint(source0,target0,min,max));
				tcn.addIntervalConstraint(i);
			}
			else
			{
				IntervalConstraint::Ptr i(new IntervalConstraint(edge->getSourceVariable(),edge->getTargetVariable(),edge->getLowerBound(),edge->getUpperBound()));
				tcn.addIntervalConstraint(i);
			}
			prevEdge = edge;
			edge = nextEdge;
		}
		else
		{
			// if the number of edges of our initial tcn is 1; then we just need to add that edge
			// otherwise I need to check if the last edge was already added into to the graph or not (compare it with prevEdge)
			if (n!=1)
			{
				if (prevEdge->getSourceVariable() != edge->getSourceVariable() || prevEdge->getTargetVariable() != edge->getTargetVariable())
				{
					IntervalConstraint::Ptr i(new IntervalConstraint(edge->getSourceVariable(),edge->getTargetVariable(),edge->getLowerBound(),edge->getUpperBound()));
					tcn.addIntervalConstraint(i);
				}
			}
			else
			{
				IntervalConstraint::Ptr i(new IntervalConstraint(edge->getSourceVariable(),edge->getTargetVariable(),edge->getLowerBound(),edge->getUpperBound()));
				tcn.addIntervalConstraint(i);
			}
			break;
		}
	}
	// update mpDistanceGraph with the one that we just created (tcn)
	mpDistanceGraph = tcn.mpDistanceGraph->copy();
}

// the intersection between a temporal constraint network and a simple temporal constraint network
graph_analysis::BaseGraph::Ptr TemporalConstraintNetwork::intersection(graph_analysis::BaseGraph::Ptr other)
{
	// complex temporal constraint network
	BaseGraph::Ptr graph0 = mpDistanceGraph->copy();

	// simple temporal constraint network
	BaseGraph::Ptr graph1 = other->copy();

	// the intersection result
	TemporalConstraintNetwork tcn;

	EdgeIterator::Ptr edgeIt1 = graph1->getEdgeIterator();
	TimePoint::Ptr source,target;
	IntervalConstraint::Ptr edge0,edge1;

	double cnt=0;
	
	// iterate through the simple temporal constraint network
	while (edgeIt1->next()) 
	{
		edge1 = boost::dynamic_pointer_cast<IntervalConstraint>( edgeIt1->current() );
		source = edge1 -> getSourceVariable();
		target = edge1 -> getTargetVariable();
		EdgeIterator::Ptr edgeIt0 = graph0->getEdgeIterator();
		// for each edge from the simple temporal constraint network; iterate through the complex temporal constraint network
		while (edgeIt0->next())
		{
			// if we find two edges (one from each graph) which have the same source and target variables
			// then we look at their upper and lower bounds
			edge0 = boost::dynamic_pointer_cast<IntervalConstraint>( edgeIt0->current() );
			if (target == edge0->getTargetVariable() && source == edge0->getSourceVariable())
			{
				/* edge1: [x--------------y]
				   edge0: 	 [a-------b]
				   => add:   [a-------b]
				*/     
				if (edge1->getLowerBound() <= edge0->getLowerBound() && edge1->getUpperBound() >= edge0->getUpperBound())
				{
					IntervalConstraint::Ptr i(new IntervalConstraint(source, target, edge0->getLowerBound(), edge0->getUpperBound()));
					tcn.addIntervalConstraint(i);
					cnt++;
				}
				else
				/*  edge1: [x------------y]
					edge0:      [a------------b]
					=> add:     [a-------y] 
				*/
				if (edge1->getLowerBound() <= edge0->getLowerBound() && edge1->getUpperBound() <= edge0->getUpperBound())
				{
					if (edge0->getLowerBound() <= edge1->getUpperBound())
					{
						IntervalConstraint::Ptr i(new IntervalConstraint(source, target, edge0->getLowerBound(), edge1->getUpperBound()));
						tcn.addIntervalConstraint(i);
						cnt++;
					}
				}
				else
				/*  edge1:        [x-----------y]
				    edge0:    [a---------b]
				    => add:       [x-----b]
				*/
				if (edge1->getLowerBound() >= edge0->getLowerBound() && edge1->getUpperBound() >= edge0->getUpperBound())
				{
					if (edge0->getUpperBound() >= edge1->getLowerBound())
					{
						IntervalConstraint::Ptr i(new IntervalConstraint(source, target, edge1->getLowerBound(), edge0->getUpperBound()));
						tcn.addIntervalConstraint(i);
						cnt++;
					}
				}
				else
				/*  edge1:     [x----y]
					edge0:  [a-----------b]
					=> add:    [x----y]
				*/
				if (edge1->getLowerBound() >= edge0->getLowerBound() && edge1->getUpperBound() <= edge0->getUpperBound())
				{
					IntervalConstraint::Ptr i(new IntervalConstraint(source, target, edge1->getLowerBound(), edge1->getUpperBound()));
					tcn.addIntervalConstraint(i);
					cnt++;
				}
				// otherwise:
				/*  edge1:  [x----y]
					edge0:            [a----b]
					or
					edge1:            [x----y]
					edge0:  [a----b]
					=> we don't add anything
				*/
			}
		}
	}
	mpDistanceGraph = tcn.mpDistanceGraph->copy();
	// update mpDistanceGraph with the one that we just created (tcn)
	return mpDistanceGraph;
}

// Change A ------[lowerBound,uppperBound]------> B into:
/* 
           A --- weight:   upper bound --> B
           B --- weight: - lower bound --> A
*/
graph_analysis::BaseGraph::Ptr TemporalConstraintNetwork::toWeightedGraph()
{
	BaseGraph::Ptr graph(new graph_analysis::lemon::DirectedGraph());
	BaseGraph::Ptr tcn = mpDistanceGraph->copy();
	EdgeIterator::Ptr edgeIt = tcn->getEdgeIterator();

	while (edgeIt->next())
    {
    	IntervalConstraint::Ptr edge0 = boost::dynamic_pointer_cast<IntervalConstraint>( edgeIt->current() );
        WeightedEdge::Ptr edge1(new WeightedEdge(edge0->getUpperBound()));
        edge1->setSourceVertex(edge0->getSourceVariable());
        edge1->setTargetVertex(edge0->getTargetVariable());
        graph->addEdge(edge1);

        WeightedEdge::Ptr edge2(new WeightedEdge(-edge0->getLowerBound()));
        edge2->setSourceVertex(edge0->getTargetVariable());
        edge2->setTargetVertex(edge0->getSourceVariable());
        graph->addEdge(edge2);
    }

    return graph;
}

//compute the minimal network of a simple temporal network using Floyd-Warshall
void TemporalConstraintNetwork::minNetwork()
{
	// Input: a simple temporal constraint network
	TemporalConstraintNetwork tcn;
	// Change its graph into a weighted graph and then apply Floyd-Warshall
	BaseGraph::Ptr graph = (toWeightedGraph())->copy();

	BaseGraph::Ptr oldGraph = mpDistanceGraph->copy();
	algorithms::DistanceMatrix distanceMatrix = algorithms::FloydWarshall::allShortestPaths(graph, [](Edge::Ptr e) -> double
                {
                    return boost::dynamic_pointer_cast<WeightedEdge>(e)->getWeight();
                });
	EdgeIterator::Ptr edgeIt = oldGraph->getEdgeIterator();

	// Change again the computed graph into a graph using Interval Constraint representation
	TimePoint::Ptr v1,v2;
	while (edgeIt->next())
	{
		IntervalConstraint::Ptr edge = boost::dynamic_pointer_cast<IntervalConstraint>(edgeIt->current());
		v1 = edge->getSourceVariable();
		v2 = edge->getTargetVariable();

		double distance12 = distanceMatrix[std::pair<TimePoint::Ptr, TimePoint::Ptr>(v1,v2)];
		double distance21 = distanceMatrix[std::pair<TimePoint::Ptr, TimePoint::Ptr>(v2,v1)];
		distance21 = (-1)*distance21;
		IntervalConstraint::Ptr i(new IntervalConstraint(v1, v2, distance21, distance12));
		tcn.addIntervalConstraint(i);	
	}
	// update mpDistanceGraph with the one that we just created (tcn)
	mpDistanceGraph = tcn.mpDistanceGraph->copy();
}

 // check if 2 temporal constraint networks are the same
bool TemporalConstraintNetwork::areEqual(graph_analysis::BaseGraph::Ptr other)
{
	EdgeIterator::Ptr edgeIt1 = mpDistanceGraph -> getEdgeIterator();
	EdgeIterator::Ptr edgeIt2 = other -> getEdgeIterator();
	// check if the graphs have the same number of vertices and edges
	if (mpDistanceGraph->size() == other->size() && mpDistanceGraph->order() == other->order())
	{
		// iterate through both graphs in the same time
		while (edgeIt1->next() && edgeIt2->next())
		{
			// check each two edges if they have the same source;target;uppper and lower bounds
			// if not; then the graphs are not the same
			IntervalConstraint::Ptr i1 = boost::dynamic_pointer_cast<IntervalConstraint>(edgeIt1->current());
			IntervalConstraint::Ptr i2 = boost::dynamic_pointer_cast<IntervalConstraint>(edgeIt2->current());
			if (i1->getSourceVariable() != i2->getSourceVariable()) return false;
			if (i1->getTargetVariable() != i2->getTargetVariable()) return false;
			if (i1->getLowerBound() != i2->getLowerBound()) return false;
			if (i1->getUpperBound() != i2->getUpperBound()) return false;
		}
		return true;
	}
	else
	{
		return false;
	}
}

// Upper-Lower-Tightening Algorithm
void TemporalConstraintNetwork::upperLowerTightening()
{
	BaseGraph::Ptr oldGraph = mpDistanceGraph->copy();
	do
	{
		// oldGraph = newGraph
		oldGraph = mpDistanceGraph->copy();
		stp();
		minNetwork();
		// newGraph becomes the minimal network
		EdgeIterator::Ptr edgeIt = oldGraph->getEdgeIterator();
		// change oldGraph into a temporal constraint network
		TemporalConstraintNetwork tcn;
		while (edgeIt->next())
		{
			IntervalConstraint::Ptr i = boost::dynamic_pointer_cast<IntervalConstraint>(edgeIt->current());
			IntervalConstraint::Ptr n(new IntervalConstraint(i->getSourceVariable(),i->getTargetVariable(),i->getLowerBound(),i->getUpperBound()));
			tcn.addIntervalConstraint(n);
		}
		tcn.intersection(mpDistanceGraph);
		// newGraph becomes the resulted graph obtained from the intersection between the oldGraph and the minimal network 
		mpDistanceGraph = (tcn.mpDistanceGraph) -> copy();
		oldGraph = oldGraph ->copy(); // reverse the order of the edges in the oldGraph in order to be able to use areEqual function 
		// (need to have the edges of the oldGraph and newGraph in the same order because we are iterating through both graphs in the same time)
	} while (!areEqual(oldGraph)); // until newGraph = oldGraph
}

int TemporalConstraintNetwork::getEdgeNumber()
{
	EdgeIterator::Ptr edgeIt = mpDistanceGraph->getEdgeIterator();
	int cnt=0;
	while (edgeIt->next()) cnt++;
	return cnt;
}

} // end namespace temporal
} // end namespace solvers
} // end namespace templ
