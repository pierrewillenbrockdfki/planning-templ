#ifndef TEMPL_SOLVERS_TEMPORAL_TEMPORAL_CONSTRAINT_NETWORK
#define TEMPL_SOLVERS_TEMPORAL_TEMPORAL_CONSTRAINT_NETWORK

#include <templ/solvers/ConstraintNetwork.hpp>
#include <templ/solvers/temporal/Bounds.hpp>
#include <templ/solvers/temporal/point_algebra/TimePoint.hpp>

namespace templ {
namespace solvers {
namespace temporal {

/**
 * \class TemporalConstraintNetwork
 * \brief Abstraction of qualitative and quantitative temporal constraint
 * networks
 */
class TemporalConstraintNetwork : public ConstraintNetwork
{
protected:
    graph_analysis::BaseGraph::Ptr mpDistanceGraph;

public:
    typedef boost::shared_ptr<TemporalConstraintNetwork> Ptr;

    TemporalConstraintNetwork();

    virtual ~TemporalConstraintNetwork();

    void addTimePoint(point_algebra::TimePoint::Ptr t);

    void addInterval(point_algebra::TimePoint::Ptr source, point_algebra::TimePoint::Ptr target, const Bounds& bound);

    virtual bool isConsistent() { throw std::runtime_error("templ::solvers::temporal::TemporalConstraintNetwork::isConsistent is not implemented"); }

    // stp(N) is generated by upper-lower bounds of range on disjunctive intervals
    /*graph_analysis::BaseGraph::Ptr*/ int stp();

    // Upper-Lower-Tightening Algorithm
    /*graph_analysis::BaseGraph::Ptr*/ void ult();

    // the intersection between two relations
    /*graph_analysis::BaseGraph::Ptr*/double intersection(TemporalConstraintNetwork);

    graph_analysis::BaseGraph::Ptr getDistanceGraph() const { return mpDistanceGraph; }

    int getEdgeNumber();
};

} // end namespace temporal
} // end namespace solvers
} // end namespace templ
#endif // TEMPL_SOLVERS_TEMPORAL_TEMPORAL_CONSTRAINT_NETWORK
